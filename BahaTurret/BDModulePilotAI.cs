//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18449
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;

namespace BahaTurret
{
	public class BDModulePilotAI : PartModule
	{
		public enum SteerModes{NormalFlight, Aiming}
		SteerModes steerMode = SteerModes.NormalFlight;

		public enum PilotCommands{Free, Orbit, Attack, Follow, FlyTo}


		[KSPField(isPersistant = true)]
		public bool pilotEnabled = false;

		bool startedLanded = false;
		bool extending = false;

		GameObject vobj;
		Transform velocityTransform
		{
			get
			{
				if(!vobj)
				{
					vobj = new GameObject("velObject");
					vobj.transform.position = vessel.ReferenceTransform.position;
					vobj.transform.parent = vessel.ReferenceTransform;
				}

				return vobj.transform;
			}
		}

		Vessel targetVessel;

		Transform vesselTransform;

		Vector3 upDirection = Vector3.up;

		public MissileFire weaponManager;

		[KSPField(isPersistant = true, guiActive = true, guiActiveEditor = true, guiName = "Default Alt."),
		 UI_FloatRange(minValue = 500f, maxValue = 8500f, stepIncrement = 25f, scene = UI_Scene.All)]
		public float defaultAltitude = 1500;
		
		[KSPField(isPersistant = true, guiActive = true, guiActiveEditor = true, guiName = "Min Altitude"),
		 UI_FloatRange(minValue = 150f, maxValue = 8500, stepIncrement = 10f, scene = UI_Scene.All)]
		public float minAltitude = 900;

		[KSPField(isPersistant = true, guiActive = true, guiActiveEditor = true, guiName = "Steer Factor"),
		 UI_FloatRange(minValue = 0.1f, maxValue = 20f, stepIncrement = .1f, scene = UI_Scene.All)]
		public float steerMult = 14;
		//make a combat steer mult and idle steer mult
		
		[KSPField(isPersistant = true, guiActive = true, guiActiveEditor = true, guiName = "Steer Limiter"),
		 UI_FloatRange(minValue = .1f, maxValue = 1f, stepIncrement = .05f, scene = UI_Scene.All)]
		public float maxSteer = 1;
		
		[KSPField(isPersistant = true, guiActive = true, guiActiveEditor = true, guiName = "Steer Damping"),
		 UI_FloatRange(minValue = 1f, maxValue = 8f, stepIncrement = 0.5f, scene = UI_Scene.All)]
		public float steerDamping = 5;

		[KSPField(isPersistant = true, guiActive = true, guiActiveEditor = true, guiName = "Max Speed"),
		 UI_FloatRange(minValue = 125f, maxValue = 800f, stepIncrement = 1.0f, scene = UI_Scene.All)]
		public float maxSpeed = 325;

		[KSPField(isPersistant = true, guiActive = true, guiActiveEditor = true, guiName = "TakeOff Speed"),
			UI_FloatRange(minValue = 20f, maxValue = 200f, stepIncrement = 1.0f, scene = UI_Scene.All)]
		public float takeOffSpeed = 70;

		[KSPField(isPersistant = true, guiActive = true, guiActiveEditor = true, guiName = "MinCombatSpeed"),
			UI_FloatRange(minValue = 20f, maxValue = 200f, stepIncrement = 1.0f, scene = UI_Scene.All)]
		public float minSpeed = 120;

        [KSPField(isPersistant = true, guiActive = true, guiActiveEditor = true, guiName = "Max G"),
         UI_FloatRange(minValue = 2f, maxValue = 25f, stepIncrement = 0.25f, scene = UI_Scene.All)]
        public float maxAllowedGForce = 10;

        [KSPField(isPersistant = true, guiActive = true, guiActiveEditor = true, guiName = "Max AoA"),
         UI_FloatRange(minValue = 0f, maxValue = 90f, stepIncrement = 2.5f, scene = UI_Scene.All)]
        public float maxAllowedAoA = 35;
        float maxAllowedCosAoA = 0;
        float lastAllowedAoA = 0;

        [KSPField(isPersistant = true, guiActive = true, guiActiveEditor = true, guiName = "Standby Mode"),
		 UI_Toggle(enabledText = "On", disabledText = "Off")]
		public bool standbyMode = false;

        //manueuverability and g loading data
        float maxPosG = 0;
        float cosAoAAtMaxPosG = 0;

        float maxNegG = 0;
        float cosAoAAtMaxNegG = 0;

        float gaoASlopePerDynPres = 0;        //used to limit control input at very high dynamic pressures to avoid structural failure
        float gOffsetPerDynPres = 0;

        float posPitchDynPresLimitIntegrator = 1;
        float negPitchDynPresLimitIntegrator = -1;

        float lastCosAoA = 0;
        float lastPitchInput = 0;

        //instantaneous turn radius and possible acceleration from lift
        //properties can be used so that other AI modules can read this for future maneuverability comparisons between craft
        float turnRadius;
        public float TurnRadius
        {
            get { return turnRadius; }
            private set { turnRadius = value; }
        }

        float maxLiftAcceleration;
        public float MaxLiftAcceleration
        {
            get { return maxLiftAcceleration; }
            private set { maxLiftAcceleration = value; }
        }

        
        float threatLevel = 1;
		float turningTimer = 0;
		float evasiveTimer = 0;
		Vector3 lastTargetPosition;

		string debugString = string.Empty;

		LineRenderer lr;
		Vector3 flyingToPosition;

		Vector3d defaultOrbitCoords;

		//speed controller
		BDAirspeedControl speedController;
		bool useAB = true;
		bool useBrakes = true;

		//collision detection
		int collisionDetectionTicker = 0;
		float collisionDetectionTimer = 0;
		Vector3 collisionAvoidDirection;

		//wing command
		int commandFollowIndex = 0;
		PilotCommands command;
		ModuleWingCommander commandLeader;
		bool useRollHint = false;
		Vector3d commandGeoPos;
		Vector3d commandPosition
		{
			get
			{
				return VectorUtils.GetWorldSurfacePostion(commandGeoPos, vessel.mainBody);
			}
			set
			{
				commandGeoPos = VectorUtils.WorldPositionToGeoCoords(value, vessel.mainBody);
			}
		}
		double commandSpeed;
		Vector3d commandHeading;
		public string currentCommand
		{
			get
			{
				return Enum.GetName(typeof(PilotCommands), command);
			}
		}


		void Start()
		{
			if(HighLogic.LoadedSceneIsFlight)
			{
				part.OnJustAboutToBeDestroyed += DeactivatePilot;
				vessel.OnJustAboutToBeDestroyed += DeactivatePilot;

				if(pilotEnabled)
				{
					ActivatePilot();
				}
                maxAllowedCosAoA = (float)Math.Cos(maxAllowedAoA * Math.PI / 180.0);
                lastAllowedAoA = maxAllowedAoA;
			}

			RefreshPartWindow();
		}

		[KSPAction("Activate Pilot")]
		public void AGActivatePilot(KSPActionParam param)
		{
			ActivatePilot();
		}

		[KSPAction("Deactivate Pilot")]
		public void AGDeactivatePilot(KSPActionParam param)
		{
			DeactivatePilot();
		}

		[KSPAction("Toggle Pilot")]
		public void AGTogglePilot(KSPActionParam param)
		{
			TogglePilot();
		}


		public void ActivatePilot()
		{
			pilotEnabled = true;
			vessel.OnFlyByWire -= AutoPilot;
			vessel.OnFlyByWire += AutoPilot;
			startedLanded = vessel.Landed;

			if(!speedController)
			{
				speedController = gameObject.AddComponent<BDAirspeedControl>();
				speedController.vessel = vessel;
			}

			speedController.Activate();

			GameEvents.onVesselDestroy.Remove(RemoveAutopilot);
			GameEvents.onVesselDestroy.Add(RemoveAutopilot);

			defaultOrbitCoords = VectorUtils.WorldPositionToGeoCoords(vessel.ReferenceTransform.position, vessel.mainBody);

			RefreshPartWindow();
		}

		public void DeactivatePilot()
		{
			pilotEnabled = false;
			vessel.OnFlyByWire -= AutoPilot;
			RefreshPartWindow();

			if(speedController)
			{
				speedController.Deactivate();
			}
		}

		void RemoveAutopilot(Vessel v)
		{
			if(v == vessel)
			{
				v.OnFlyByWire -= AutoPilot;
			}
		}



		[KSPEvent(guiActive = true, guiName = "Toggle Pilot", active = true)]
		public void TogglePilot()
		{
			if(pilotEnabled)
			{
				DeactivatePilot();
			}
			else
			{
				ActivatePilot();
			}
		}

		void RefreshPartWindow()
		{
			Events["TogglePilot"].guiName = pilotEnabled ? "Deactivate Pilot" : "Activate Pilot";

			//Misc.RefreshAssociatedWindows(part);
		}

		void Update()
		{
			if(BDArmorySettings.DRAW_DEBUG_LINES && pilotEnabled)
			{
				if(lr)
				{
					lr.enabled = true;
					lr.SetPosition(0, vessel.ReferenceTransform.position);
					lr.SetPosition(1, flyingToPosition);
				}
				else
				{
					lr = gameObject.AddComponent<LineRenderer>();
					lr.SetVertexCount(2);
					lr.SetWidth(0.5f, 0.5f);
				}
			}
			else
			{
				if(lr)
				{
					lr.enabled = false;
				}
			}
		}


		void AutoPilot(FlightCtrlState s)
		{
			if(!vessel || !vessel.transform || vessel.packed || !vessel.mainBody)
			{
				return;
			}
			vesselTransform = vessel.ReferenceTransform;

			//default brakes off full throttle
			//s.mainThrottle = 1;

			//vessel.ActionGroups.SetGroup(KSPActionGroup.Brakes, false);
			AdjustThrottle(maxSpeed, true);
			useAB = true;
			useBrakes = true;
			vessel.ActionGroups.SetGroup(KSPActionGroup.SAS, true);

			steerMode = SteerModes.NormalFlight;


			GetGuardTarget();
			if(vessel.Landed && standbyMode && weaponManager && BDATargetManager.TargetDatabase[BDATargetManager.BoolToTeam(weaponManager.team)].Count == 0)
			{
				//s.mainThrottle = 0;
				//vessel.ActionGroups.SetGroup(KSPActionGroup.Brakes, true);
				AdjustThrottle(0, true);
				return;
			}
			//upDirection = -FlightGlobals.getGeeForceAtPosition(transform.position).normalized;
			upDirection = VectorUtils.GetUpDirection(vessel.transform.position);
			debugString = string.Empty;

            CalculateAccelerationAndTurningCircle();
            if (MissileGuidance.GetRadarAltitude(vessel) < MinAltitudeNeeded())
			{
				startedLanded = true;
			}



            if (startedLanded)
			{
				TakeOff(s);
				turningTimer = 0;
			}
			else
			{
				if(FlyAvoidCollision(s))
				{
					turningTimer = 0;
				}
				else if(command != PilotCommands.Free)
				{
					UpdateCommand(s);
				}
				else
				{
					UpdateAI(s);
				}
			}
            UpdateGAndAoALimits(s);
            AdjustPitchForGAndAoALimits(s);
			//brake and cut throttle if exceeding max speed
			/*
			if(vessel.srfSpeed > maxSpeed)
			{
				vessel.ActionGroups.SetGroup(KSPActionGroup.Brakes, true);
				s.mainThrottle = 0;
			}
			*/

			debugString += "\nthreatLevel: " + threatLevel;
		}

		void UpdateAI(FlightCtrlState s)
		{
			if(weaponManager && weaponManager.guardMode && !targetVessel)
			{
				TargetInfo potentialTarget = BDATargetManager.GetLeastEngagedTarget(weaponManager);
				if(potentialTarget && potentialTarget.Vessel)
				{
					targetVessel = potentialTarget.Vessel;
				}
			}

			if(evasiveTimer > 0 || (weaponManager && (weaponManager.missileIsIncoming || weaponManager.isChaffing || weaponManager.isFlaring || weaponManager.underFire)))
			{
				Evasive(s);
				evasiveTimer += Time.fixedDeltaTime;
				turningTimer = 0;

				if(evasiveTimer > 5) evasiveTimer = 0;
			}
			else if(!extending && weaponManager && targetVessel != null && targetVessel.transform != null)
			{
				if(!targetVessel.Landed)
				{
					if(vessel.altitude < defaultAltitude && Vector3.Angle(targetVessel.transform.position - vessel.transform.position, -upDirection) < 35)
					{
						//dangerous if low altitude and target is far below you - don't dive into ground!
						extending = true;
						lastTargetPosition = targetVessel.transform.position;
					}

					if(Vector3.Angle(targetVessel.transform.position - vesselTransform.position, vesselTransform.up) > 35)
					{
						turningTimer += Time.deltaTime;
					}
					else
					{
						turningTimer = 0;
					}

					debugString += "turningTimer: " + turningTimer;

					if(turningTimer > 15)
					{
						//extend if turning circles for too long
						extending = true;
						turningTimer = 0;
						lastTargetPosition = targetVessel.transform.position;
					}
				}
				else //extend if too close for agm attack
				{
					float extendDistance = Mathf.Clamp(weaponManager.guardRange - 1800, 2500, 4000);
					float srfDist = Vector3.Distance(GetSurfacePosition(targetVessel.transform.position), GetSurfacePosition(vessel.transform.position));

					if(srfDist < extendDistance && Vector3.Angle(vesselTransform.up, targetVessel.transform.position - vessel.transform.position) > 45)
					{
						extending = true;
						lastTargetPosition = targetVessel.transform.position;
					}
				}

				if(!extending)
				{
					debugString += "\nFlying to target";
					threatLevel = 1;
					FlyToTargetVessel(s, targetVessel);
				}
			}
			else
			{
				if(!extending)
				{
					//FlyCircular(s);
					FlyOrbit(s, defaultOrbitCoords, 2000, minSpeed, true);
				}
			}

			if(extending)
			{
				threatLevel = 1;
				debugString += "\nExtending";
				FlyExtend(s, lastTargetPosition);
			}
		}


		bool FlyAvoidCollision(FlightCtrlState s)
		{
			if(collisionDetectionTimer > 5)
			{
				collisionDetectionTimer = 0;
			}
			if(collisionDetectionTimer > 0)
			{
				//fly avoid
				debugString += "\nAvoiding Collision";
				collisionDetectionTimer += Time.fixedDeltaTime;


				Vector3 target = vesselTransform.position + collisionAvoidDirection;
				FlyToPosition(s, target);
				return true;
			}
			else if(collisionDetectionTicker > 30)
			{
				collisionDetectionTicker = 0;
				if(DetectCollision(flyingToPosition - vesselTransform.position))
				{
					collisionDetectionTimer += Time.fixedDeltaTime;
					Vector3 badDirection = flyingToPosition - vesselTransform.position;
					Vector3 axis = -Vector3.Cross(vesselTransform.up, badDirection);
					axis = Vector3.Project(axis, upDirection);
					collisionAvoidDirection = Quaternion.AngleAxis(90, axis) * badDirection; //need to change axis to opposite of direction to collision
				}
			}
			else
			{
				collisionDetectionTicker++;
			}

			return false;
		}

		void FlyToTargetVessel(FlightCtrlState s, Vessel v)
		{
			Vector3 target = v.CoM;
			MissileLauncher missile = null;
			Vector3 vectorToTarget = v.transform.position - vesselTransform.position;
			float distanceToTarget = vectorToTarget.magnitude;
			if(weaponManager)
			{
				missile = weaponManager.currentMissile;
				if(missile != null)
				{
					if(missile.targetingMode == MissileLauncher.TargetingModes.Heat && !weaponManager.heatTarget.exists)
					{
						target += v.srf_velocity.normalized * 10;
					}
					else
					{
						target = MissileGuidance.GetAirToAirFireSolution(missile, v);
					}

					if(Vector3.Angle(target - vesselTransform.position, vesselTransform.forward) < 15)
					{
						steerMode = SteerModes.Aiming;
					}
            	}
				else
				{
					ModuleWeapon weapon = weaponManager.currentGun;
					if(weapon!=null)
					{
						//target -= 1.30f*weapon.GetLeadOffset();
						Vector3 leadOffset = weapon.GetLeadOffset();

						float targetAngVel = 1.65f * Vector3.Angle(v.transform.position - vessel.transform.position, v.transform.position + (vessel.srf_velocity) - vessel.transform.position);
						debugString += "\ntargetAngVel: " + targetAngVel;
						float magnifier = Mathf.Clamp(targetAngVel, 1.25f, 5);
						target -= magnifier * leadOffset;
						float angleToLead = Vector3.Angle(vesselTransform.up, target - vesselTransform.position);
						if(distanceToTarget < 1600 &&  angleToLead < 20)
						{
							steerMode = SteerModes.Aiming; //steer to aim
						}
					}
				}
			}





			float targetDot = Vector3.Dot(vesselTransform.up, v.transform.position-vessel.transform.position);

			//manage speed when close to enemy
			float finalMaxSpeed = ((distanceToTarget-100)/8) + (float)v.srfSpeed;
			AdjustThrottle(finalMaxSpeed, true);
		
			if((targetDot < 0 || vessel.srfSpeed > finalMaxSpeed)
				&& distanceToTarget < 800) //distance is less than 800m
			{
				debugString += ("\nEnemy on tail. Braking");
				AdjustThrottle(minSpeed, true);
			}
			if(missile!=null 
				&& targetDot > 0
				&& distanceToTarget < 300
			   && vessel.srfSpeed > 130)
			{
				extending = true;
				lastTargetPosition = v.transform.position;
			}


			FlyToPosition(s, target);
		}



		void RegainEnergy(FlightCtrlState s)
		{
			debugString += "\nRegaining energy";
			steerMode = SteerModes.Aiming;
			Vector3 planarDirection = Vector3.ProjectOnPlane(vessel.srf_velocity, upDirection);
			float angle = (Mathf.Clamp(MissileGuidance.GetRadarAltitude(vessel) - minAltitude, 0, 1500) / 1500) * 90;
			angle = Mathf.Clamp(angle, 0, 55) * Mathf.Deg2Rad;
			Vector3 targetDirection = Vector3.RotateTowards(planarDirection, -upDirection, angle, 0).normalized;
		
			AdjustThrottle(maxSpeed, false);
			FlyToPosition(s, vesselTransform.position + (targetDirection*100));
		}


					

		void FlyToPosition(FlightCtrlState s, Vector3 targetPosition)
		{
			if(!startedLanded)
			{
				targetPosition = FlightPosition(targetPosition, minAltitude);
				targetPosition = vesselTransform.position + ((targetPosition - vesselTransform.position).normalized * 100);
			}

			Vector3d srfVel = vessel.srf_velocity;
			if(srfVel != Vector3d.zero)
			{
				velocityTransform.rotation = Quaternion.LookRotation(srfVel, -vesselTransform.forward);
			}
			velocityTransform.rotation = Quaternion.AngleAxis(90, velocityTransform.right) * velocityTransform.rotation;
			Vector3 localAngVel = vessel.angularVelocity;

			float angleToTarget = Vector3.Angle(targetPosition - vesselTransform.position, vesselTransform.up);
			if(steerMode == SteerModes.NormalFlight)
			{
				//Vector3 dampedDirection = Vector3.RotateTowards(vesselTransform.up, targetPosition - vesselTransform.position, (angleToTarget / 2) * Mathf.Deg2Rad, 0).normalized;
				//targetPosition = vesselTransform.position + (100 * dampedDirection);
			}

			if(BDArmorySettings.DRAW_DEBUG_LINES)
			{
				flyingToPosition = targetPosition;
			}

			//slow down for tighter turns
			float velAngleToTarget = Vector3.Angle(targetPosition-vesselTransform.position, vessel.srf_velocity);
			float normVelAngleToTarget = Mathf.Clamp(velAngleToTarget, 0, 90)/90;
			float speedReductionFactor = 1.25f;
			float finalSpeed = Mathf.Min(speedController.targetSpeed, Mathf.Clamp(maxSpeed - (speedReductionFactor * normVelAngleToTarget), minSpeed, maxSpeed));
			debugString += "\nFinal Target Speed: " + finalSpeed.ToString("0.0");
			AdjustThrottle(finalSpeed, useBrakes, useAB);

			Vector3 targetDirection;
			Vector3 targetDirectionYaw;
			float yawError;
			float pitchError;
			float postYawFactor;
			float postPitchFactor;
			if(steerMode == SteerModes.NormalFlight)
			{
				targetDirection = velocityTransform.InverseTransformDirection(targetPosition - velocityTransform.position).normalized;
				targetDirection = Vector3.RotateTowards(Vector3.up, targetDirection, 45 * Mathf.Deg2Rad, 0);

				targetDirectionYaw = vesselTransform.InverseTransformDirection(vessel.srf_velocity).normalized;
				targetDirectionYaw = Vector3.RotateTowards(Vector3.up, targetDirectionYaw, 45 * Mathf.Deg2Rad, 0);


				postYawFactor = 1;
				postPitchFactor = 1;

				if(command == PilotCommands.Orbit)
				{
					postPitchFactor = 0.85f;
				}
			}
			else//(steerMode == SteerModes.Aiming)
			{
				targetDirection = vesselTransform.InverseTransformDirection(targetPosition-vesselTransform.position).normalized;
				targetDirection = Vector3.RotateTowards(Vector3.up, targetDirection, 45 * Mathf.Deg2Rad, 0);
				targetDirectionYaw = targetDirection;

				if(command == PilotCommands.Follow)
				{
					postYawFactor = 1.3f;
					postPitchFactor = 1f;
				}
				else
				{
					postYawFactor = 1.5f;
					postPitchFactor = 2.4f;
				}
			}

			pitchError = VectorUtils.SignedAngle(Vector3.up, Vector3.ProjectOnPlane(targetDirection, Vector3.right), Vector3.back);
			yawError = VectorUtils.SignedAngle(Vector3.up, Vector3.ProjectOnPlane(targetDirectionYaw, Vector3.forward), Vector3.right);



			float finalMaxSteer = threatLevel * maxSteer;

			float steerPitch = (postPitchFactor * 0.015f * steerMult * pitchError) - (postPitchFactor * steerDamping * -localAngVel.x);
			float steerYaw = (postYawFactor * 0.022f * steerMult * yawError) - (postYawFactor * steerDamping * -localAngVel.z);
	

			s.yaw = Mathf.Clamp(steerYaw, -finalMaxSteer, finalMaxSteer);
			s.pitch = Mathf.Clamp(steerPitch, Mathf.Min(-finalMaxSteer, -0.2f), finalMaxSteer);


			//roll
			Vector3 currentRoll = -vesselTransform.forward;
			Vector3 rollTarget;

			//if(steerMode == SteerModes.Aiming || angleToTarget > 2)
			//{
				rollTarget = (targetPosition + ((steerMode == SteerModes.Aiming ? 10f : 30f) * upDirection)) - vesselTransform.position;
			//}
			//else
			//{
			//	rollTarget = upDirection;
			//}

			if(command == PilotCommands.Follow && useRollHint)
			{
				rollTarget = -commandLeader.vessel.ReferenceTransform.forward;
			}

			rollTarget = Vector3.ProjectOnPlane(rollTarget, vesselTransform.up);





			
			float rollError = Misc.SignedAngle(currentRoll, rollTarget, vesselTransform.right);
			debugString += "\nRoll offset: "+rollError;
			float steerRoll = (steerMult * 0.0015f * rollError);
			debugString += "\nSteerRoll: "+steerRoll;
			float rollDamping = (.10f * steerDamping * -localAngVel.y);
			steerRoll -= rollDamping;
			debugString += "\nRollDamping: "+rollDamping;



			float roll = Mathf.Clamp(steerRoll, -maxSteer, maxSteer);
			s.roll = roll;
			//
		}

		void FlyExtend(FlightCtrlState s, Vector3 tPosition)
		{
			if(vessel.srfSpeed < minSpeed)
			{
				RegainEnergy(s);
				return;
			}

			if(weaponManager)
			{
				float extendDistance = Mathf.Clamp(weaponManager.guardRange-1800, 2500, 4000);
				if(targetVessel!=null && !targetVessel.Landed)
				{
					extendDistance = 800;
				}

				Vector3 srfVector = Vector3.ProjectOnPlane(vessel.transform.position - tPosition, upDirection);
				float srfDist = srfVector.magnitude;
				if(srfDist < extendDistance)
				{
					Vector3 targetDirection = srfVector.normalized*extendDistance;
					Vector3 target = vessel.transform.position + targetDirection;
					FlyToPosition(s, target);
				}
				else
				{
					extending = false;
				}
			}
			else
			{
				extending = false;
			}
		}

		void FlyCircular(FlightCtrlState s)
		{
			debugString += "\nFlying circular";

			if(vessel.srfSpeed < minSpeed)
			{
				RegainEnergy(s);
			}

			bool enemiesNearby = false;
			if(weaponManager)
			{
				BDArmorySettings.BDATeams team = weaponManager.team ? BDArmorySettings.BDATeams.B : BDArmorySettings.BDATeams.A;
				if(BDATargetManager.TargetDatabase[team].Count > 0)
				{
					threatLevel = 1;
					enemiesNearby = true;
				}
			}

			if(!enemiesNearby)
			{
				threatLevel = Mathf.MoveTowards(threatLevel, 0.5f, 0.05f*Time.deltaTime);
			}
			Vector3 axis = Vector3.Project(-vesselTransform.right, upDirection).normalized;
			Vector3 target = DefaultAltPosition() + Quaternion.AngleAxis(15, axis) * Vector3.ProjectOnPlane(vesselTransform.up * 1000, upDirection);
			Vector3 dirToAxis = target - vesselTransform.position;
			dirToAxis = Vector3.RotateTowards(Vector3.ProjectOnPlane(dirToAxis, upDirection), dirToAxis, 15 * Mathf.Deg2Rad, 0).normalized;
			target = vesselTransform.position + (dirToAxis * 1000);
			FlyToPosition(s, target);
		}

		void FlyOrbit(FlightCtrlState s, Vector3d centerGPS, float radius, float speed, bool clockwise)
		{
			if(vessel.srfSpeed < minSpeed * 0.75f)
			{
				RegainEnergy(s);
				return;
			}

			debugString += "\nFlying orbit";
			Vector3 flightCenter = GetTerrainSurfacePosition(VectorUtils.GetWorldSurfacePostion(centerGPS, vessel.mainBody)) + (defaultAltitude*upDirection);

			Vector3 myVectorFromCenter = Vector3.ProjectOnPlane(vessel.transform.position - flightCenter, upDirection);
			Vector3 myVectorOnOrbit = myVectorFromCenter.normalized * radius;

			Vector3 targetVectorFromCenter = Quaternion.AngleAxis(clockwise ? 15 : -15, upDirection) * myVectorOnOrbit;

			Vector3 verticalVelVector = Vector3.Project(vessel.srf_velocity, upDirection); //for vv damping

			Vector3 targetPosition = flightCenter + targetVectorFromCenter - (verticalVelVector * 0.25f);

			Vector3 vectorToTarget = targetPosition - vesselTransform.position;
			Vector3 planarVel = Vector3.ProjectOnPlane(vessel.srf_velocity, upDirection);
			vectorToTarget = Vector3.RotateTowards(planarVel, vectorToTarget, 25 * Mathf.Deg2Rad, 0);

			AdjustThrottle(speed, false);
			FlyToPosition(s, targetPosition);
		}

		//sends target speed to speedController
		void AdjustThrottle(float targetSpeed, bool useBrakes, bool allowAfterburner = true)
		{
			speedController.targetSpeed = targetSpeed;
			speedController.useBrakes = useBrakes;
			speedController.allowAfterburner = allowAfterburner;
		}

		void Evasive(FlightCtrlState s)
		{
			debugString += "\nEvasive";
			debugString += "\n Threat Distance: " + weaponManager.incomingMissileDistance;
			if(weaponManager && (weaponManager.isChaffing || weaponManager.isFlaring) && weaponManager.incomingMissileDistance > 2000)
			{
				RegainEnergy(s);
				return;
			}
			threatLevel = 1f;
			Vector3 target = (vessel.srfSpeed < 200) ? FlightPosition(vessel.transform.position, minAltitude) : vesselTransform.position;
			float angleOff = Mathf.Sin(Time.time * 0.75f) * 180;
			angleOff = Mathf.Clamp(angleOff, -45, 45);
			target +=
				(Quaternion.AngleAxis(angleOff, upDirection) * Vector3.ProjectOnPlane(vesselTransform.up * 500, upDirection));
				//+ (Mathf.Sin (Time.time/3) * upDirection * minAltitude/3);

			if(weaponManager.isFlaring)
			{
				useAB = vessel.srfSpeed < takeOffSpeed;
				useBrakes = false;
				AdjustThrottle(minSpeed, false, useAB);
			}

			FlyToPosition(s, target);
		}

		void TakeOff(FlightCtrlState s)
		{
			threatLevel = 1;
			debugString += "\nTaking off/Gaining altitude";

			if(vessel.Landed && vessel.srfSpeed < takeOffSpeed)
			{
				defaultOrbitCoords = VectorUtils.WorldPositionToGeoCoords(vessel.transform.position, vessel.mainBody);
				return;
			}

			steerMode = SteerModes.Aiming;

			float radarAlt = MissileGuidance.GetRadarAltitude(vessel);

			Vector3 forwardPoint = vessel.transform.position + Vector3.ProjectOnPlane(vesselTransform.up * 100, upDirection);
			float terrainDiff = MissileGuidance.GetRaycastRadarAltitude(forwardPoint) - radarAlt;
			terrainDiff = Mathf.Max(terrainDiff, 0);

			float rise = Mathf.Clamp((float)vessel.srfSpeed * 0.3f, 5, 100);

			if(radarAlt > 70)
			{
				vessel.ActionGroups.SetGroup(KSPActionGroup.Gear, false);
			}
			else
			{
				vessel.ActionGroups.SetGroup(KSPActionGroup.Gear, true);
			}

			FlyToPosition(s, forwardPoint + (upDirection * (rise+terrainDiff)));

			if(radarAlt > minAltitude)
			{
				startedLanded = false;
			}
		}

        void UpdateGAndAoALimits(FlightCtrlState s)
        {
            if (vessel.dynamicPressurekPa <= 0 || vessel.srfSpeed < takeOffSpeed || startedLanded && -Vector3.Dot(vessel.ReferenceTransform.forward, vessel.upAxis) < 0.8f)
                return;

            if(lastAllowedAoA != maxAllowedAoA)
            {
                lastAllowedAoA = maxAllowedAoA;
                maxAllowedCosAoA = (float)Math.Cos(lastAllowedAoA * Math.PI / 180.0);
            }
            float pitchG = -Vector3.Dot(vessel.acceleration, vessel.ReferenceTransform.forward);       //should provide g force in vessel up / down direction, assuming a standard plane
            float pitchGPerDynPres = pitchG / (float)vessel.dynamicPressurekPa;

            float curCosAoA = Vector3.Dot(vessel.srf_velocity / vessel.srfSpeed, vessel.ReferenceTransform.forward);
            if(pitchGPerDynPres < maxNegG || Math.Abs(curCosAoA - cosAoAAtMaxNegG) < 0.005f)
            {
                maxNegG = pitchGPerDynPres;
                cosAoAAtMaxNegG = curCosAoA;
            }
            if (pitchGPerDynPres > maxPosG || Math.Abs(curCosAoA - cosAoAAtMaxPosG) < 0.005f)
            {
                maxPosG = pitchGPerDynPres;
                cosAoAAtMaxPosG = curCosAoA;
            }

            if(cosAoAAtMaxNegG >= cosAoAAtMaxPosG)
            {
                cosAoAAtMaxNegG = cosAoAAtMaxPosG = maxNegG = maxPosG = 0;
                gOffsetPerDynPres = gaoASlopePerDynPres = 0;
                return;
            }

            float aoADiff = cosAoAAtMaxPosG - cosAoAAtMaxNegG;

            //if (Math.Abs(pitchControlDiff) < 0.005f)
            //    return;                 //if the pitch control values are too similar, don't bother to avoid numerical errors


            gaoASlopePerDynPres = (maxPosG - maxNegG) / aoADiff;
            gOffsetPerDynPres = maxPosG - gaoASlopePerDynPres * cosAoAAtMaxPosG;     //g force offset
        }

        void AdjustPitchForGAndAoALimits(FlightCtrlState s)
        {
            float minCosAoA, maxCosAoA;
            //debugString += "\nMax Pos G: " + maxPosG + " @ " + cosAoAAtMaxPosG;
            //debugString += "\nMax Neg G: " + maxNegG + " @ " + cosAoAAtMaxNegG;

            if (gaoASlopePerDynPres == 0 || vessel.srfSpeed < takeOffSpeed)         //if the slope is 0, ignore it
            {
                negPitchDynPresLimitIntegrator = -1f * 0.001f * 0.5f * 1.225f * takeOffSpeed * takeOffSpeed;
                posPitchDynPresLimitIntegrator = 1f * 0.001f * 0.5f * 1.225f * takeOffSpeed * takeOffSpeed;
                return;
            }

            float invVesselDynPreskPa = 1f / (float)vessel.dynamicPressurekPa;

            maxCosAoA = maxAllowedGForce * 9.81f * invVesselDynPreskPa;
            minCosAoA = -maxCosAoA;

            maxCosAoA -= gOffsetPerDynPres;
            minCosAoA -= gOffsetPerDynPres;

            maxCosAoA /= gaoASlopePerDynPres;
            minCosAoA /= gaoASlopePerDynPres;

            if (maxCosAoA > maxAllowedCosAoA)
                maxCosAoA = maxAllowedCosAoA;

            if (minCosAoA < -maxAllowedCosAoA)
                minCosAoA = -maxAllowedCosAoA;

            float curCosAoA = Vector3.Dot(vessel.srf_velocity / vessel.srfSpeed, vessel.ReferenceTransform.forward);


            float centerCosAoA = (minCosAoA + maxCosAoA) * 0.5f;
            float curCosAoACentered = curCosAoA - centerCosAoA;
            float cosAoADiff = 0.5f * Math.Abs(maxCosAoA - minCosAoA);
            float curCosAoANorm = curCosAoACentered / cosAoADiff;      //scaled so that from centerAoA to maxAoA is 1


            float negPitchScalar, posPitchScalar;
            negPitchScalar = negPitchDynPresLimitIntegrator * invVesselDynPreskPa - lastPitchInput;
            posPitchScalar = lastPitchInput - posPitchDynPresLimitIntegrator * invVesselDynPreskPa;

            //update pitch control limits as needed
            float negPitchDynPresLimit, posPitchDynPresLimit;
            negPitchDynPresLimit = posPitchDynPresLimit = 0;
            if (curCosAoANorm < -0.15f)// || Math.Abs(negPitchScalar) < 0.01f)
            {
                float cosAoAOffset = curCosAoANorm + 1;     //set max neg aoa to be 0
                float aoALimScalar = Math.Abs(curCosAoANorm);
                aoALimScalar *= aoALimScalar;
                aoALimScalar *= aoALimScalar;
                aoALimScalar *= aoALimScalar;
                if (aoALimScalar > 1)
                    aoALimScalar = 1;

                float pitchInputScalar = negPitchScalar;
                pitchInputScalar = 1 - Mathf.Clamp01(Math.Abs(pitchInputScalar));
                pitchInputScalar *= pitchInputScalar;
                pitchInputScalar *= pitchInputScalar;
                pitchInputScalar *= pitchInputScalar;
                if (pitchInputScalar < 0)
                    pitchInputScalar = 0;

                float deltaCosAoANorm = curCosAoA - lastCosAoA;
                deltaCosAoANorm /= cosAoADiff;

                debugString += "\nUpdating Neg Gs";
                negPitchDynPresLimitIntegrator -= 0.01f * Mathf.Clamp01(aoALimScalar + pitchInputScalar) * cosAoAOffset * (float)vessel.dynamicPressurekPa;
                negPitchDynPresLimitIntegrator -= 0.005f * deltaCosAoANorm * (float)vessel.dynamicPressurekPa;
                if (cosAoAOffset < 0)
                    negPitchDynPresLimit = -0.3f * cosAoAOffset;
            }
            if (curCosAoANorm > 0.15f)// || Math.Abs(posPitchScalar) < 0.01f)
            {
                float cosAoAOffset = curCosAoANorm - 1;     //set max pos aoa to be 0
                float aoALimScalar = Math.Abs(curCosAoANorm);
                aoALimScalar *= aoALimScalar;
                aoALimScalar *= aoALimScalar;
                aoALimScalar *= aoALimScalar;
                if (aoALimScalar > 1)
                    aoALimScalar = 1;

                float pitchInputScalar = posPitchScalar;
                pitchInputScalar = 1 - Mathf.Clamp01(Math.Abs(pitchInputScalar));
                pitchInputScalar *= pitchInputScalar;
                pitchInputScalar *= pitchInputScalar;
                pitchInputScalar *= pitchInputScalar;
                if (pitchInputScalar < 0)
                    pitchInputScalar = 0;

                float deltaCosAoANorm = curCosAoA - lastCosAoA;
                deltaCosAoANorm /= cosAoADiff;

                debugString += "\nUpdating Pos Gs";
                posPitchDynPresLimitIntegrator -= 0.01f * Mathf.Clamp01(aoALimScalar + pitchInputScalar) * cosAoAOffset * (float)vessel.dynamicPressurekPa;
                posPitchDynPresLimitIntegrator -= 0.005f * deltaCosAoANorm * (float)vessel.dynamicPressurekPa;
                if(cosAoAOffset > 0)
                    posPitchDynPresLimit = -0.3f * cosAoAOffset;
            }


            float negLim, posLim;
            negLim = negPitchDynPresLimitIntegrator * invVesselDynPreskPa + negPitchDynPresLimit;
            if (negLim > s.pitch)
            {
                s.pitch = negLim;
                debugString += "\nLimiting Neg Gs";
            }
            posLim = posPitchDynPresLimitIntegrator * invVesselDynPreskPa + posPitchDynPresLimit;
            if (posLim < s.pitch)
            {
                s.pitch = posLim;
                debugString += "\nLimiting Pos Gs";
            }            

            lastPitchInput = s.pitch;
            lastCosAoA = curCosAoA;
            debugString += "\nNeg Pitch Lim: " + negLim;
            debugString += "\nPos Pitch Lim: " + posLim;

        }

        void CalculateAccelerationAndTurningCircle()
        {
            maxLiftAcceleration = gaoASlopePerDynPres * Math.Min(cosAoAAtMaxPosG, maxAllowedCosAoA) + gOffsetPerDynPres;
            maxLiftAcceleration *= (float)vessel.dynamicPressurekPa;       //maximum acceleration from lift that the vehicle can provide

            maxLiftAcceleration = Math.Min(maxLiftAcceleration, maxAllowedGForce * 9.81f);       //limit it to whichever is smaller, what we can provide or what we can handle

            if(maxLiftAcceleration > 0)
                turnRadius = (float)vessel.srf_velocity.sqrMagnitude / maxLiftAcceleration;     //radius that we can turn in assuming constant velocity, assuming simple circular motion
        }

        float MinAltitudeNeeded()         //min altitude adjusted for G limits; let's try _not_ to overcook dives and faceplant into the ground
        {
            //for a pure vertical dive, turnRadius will be the altitude that we need to turn.  However, for shallower dives we don't need that much.  Let's account for that.
            //actual altitude needed will be radius * (1 - cos(theta)), where theta is the angle of the arc from dive entry to the turning circle to the bottom
            //we can calculate that from the velocity vector mag dotted with the up vector

            float diveAngleCorrection = -Vector3.Dot(vessel.srf_velocity / vessel.srfSpeed, vessel.upAxis); //normalize the vector and dot it with upAxis
            //this gives us sin(theta)
            if(diveAngleCorrection > 0)         //we're headed downwards
            {
                diveAngleCorrection *= diveAngleCorrection;
                diveAngleCorrection = 1 - diveAngleCorrection;
                diveAngleCorrection = Math.Max(0f, diveAngleCorrection);    //remember to check to make sure numerical errors haven't crept in!  Can't have NaN showing up
                diveAngleCorrection = Mathf.Sqrt(diveAngleCorrection);      //convert sin(theta) to cos(theta)

                diveAngleCorrection = 1 - diveAngleCorrection;      //and convert to 1 - cos(theta)
            }
            else
            {
                diveAngleCorrection = 0;
            }

            return Math.Max(minAltitude, 100 + turnRadius * diveAngleCorrection);
        }

		Vector3 DefaultAltPosition()
		{
			return (vessel.transform.position + (-(float)vessel.altitude*upDirection) + (defaultAltitude *upDirection));
		}

		Vector3 GetSurfacePosition(Vector3 position)
		{
			return position - ((float)FlightGlobals.getAltitudeAtPos(position) * upDirection);
		}

		Vector3 GetTerrainSurfacePosition(Vector3 position)
		{
			return position - (MissileGuidance.GetRaycastRadarAltitude(position) * upDirection);
		}


		Vector3 FlightPosition(Vector3 targetPosition, float minAlt)
		{
			Vector3 forwardDirection = vesselTransform.up;
			Vector3 targetDirection = (targetPosition - vesselTransform.position).normalized;
			if(Vector3.Dot(targetDirection, forwardDirection) < 0)
			{
				targetPosition = vesselTransform.position + Vector3.RotateTowards(Vector3.ProjectOnPlane(forwardDirection, upDirection), Vector3.ProjectOnPlane(targetDirection, upDirection), 90*Mathf.Deg2Rad, 0).normalized*200;
			}
			float pointRadarAlt = MissileGuidance.GetRaycastRadarAltitude(targetPosition);
			if(pointRadarAlt < minAlt)
			{
				float adjustment = (minAlt-pointRadarAlt);
				debugString += "\nTarget position is below minAlt. Adjusting by "+adjustment;
				return targetPosition + (adjustment * upDirection);
			}
			else
			{
				return targetPosition;
			}
		}

		public bool GetLaunchAuthorization(Vessel targetV, MissileFire mf)
		{
			bool launchAuthorized = false;
			Vector3 target = targetV.transform.position;
			MissileLauncher missile = mf.currentMissile;
			if(missile != null)
			{
				if(!targetV.Landed)
				{
					target = MissileGuidance.GetAirToAirFireSolution(missile, targetV);
				}

				float boresightFactor = targetV.Landed ? 0.75f : 0.35f;
				float maxOffBoresight = missile.maxOffBoresight;
				if(missile.targetingMode == MissileLauncher.TargetingModes.GPS) maxOffBoresight = 45;

				float fTime = 2f;
				Vector3 futurePos = target + (targetV.srf_velocity * fTime);
				Vector3 myFuturePos = vesselTransform.position + (vessel.srf_velocity * fTime);
				bool fDot = Vector3.Dot(vesselTransform.up, futurePos - myFuturePos) > 0; //check target won't likely be behind me soon

				if(fDot && Vector3.Angle(missile.transform.forward, target - missile.transform.position) < maxOffBoresight * boresightFactor)
				{
					launchAuthorized = true;
				}
			}

			return launchAuthorized;
		}

		void GetGuardTarget()
		{
			if(weaponManager!=null && weaponManager.vessel == vessel)
			{
				if(weaponManager.guardMode && weaponManager.currentTarget!=null)
				{
					targetVessel = weaponManager.currentTarget.Vessel;
				}
				else
				{
					targetVessel = null;
				}
				weaponManager.pilotAI = this;
				return;
			}
			else
			{
				foreach(var mf in vessel.FindPartModulesImplementing<MissileFire>())
				{
					if(mf.currentTarget!=null)
					{
						targetVessel = mf.currentTarget.Vessel;
					}
					else
					{
						targetVessel = null;
					}

					weaponManager = mf;
					mf.pilotAI = this;

					return;
				}
			}
		}

		bool DetectCollision(Vector3 direction)
		{
			if(MissileGuidance.GetRadarAltitude(vessel) < 20) return false;

			direction = direction.normalized;
			int layerMask = 557057;
			Ray ray = new Ray(vesselTransform.position + (50*vesselTransform.up), direction);
			float distance = Mathf.Clamp((float)vessel.srfSpeed * 5, 250, 2500);
			RaycastHit hit;
			if(Physics.SphereCast(ray, 10, out hit, distance, layerMask))
			{
				Rigidbody otherRb = hit.collider.attachedRigidbody;
				if(otherRb)
				{
					if(Vector3.Dot(otherRb.velocity, vessel.srf_velocity) < 0)
					{
						return true;
					}
					else
					{
						return false;
					}
				}
				else
				{
					return true;
				}
			}
			else
			{
				return false;
			}
		}

		void UpdateCommand(FlightCtrlState s)
		{
			if(!commandLeader)
			{
				ReleaseCommand();
				return;
			}

			if(command == PilotCommands.Follow)
			{
				UpdateFollowCommand(s);
			}
		}

		void UpdateFollowCommand(FlightCtrlState s)
		{
			threatLevel = 1;
			steerMode = SteerModes.NormalFlight;
			//s.mainThrottle = 1;
			vessel.ActionGroups.SetGroup(KSPActionGroup.Brakes, false);

			commandSpeed = commandLeader.vessel.srfSpeed;
			commandHeading = commandLeader.vessel.srf_velocity.normalized;

			//formation position
			commandPosition = GetFormationPosition();

			float distanceToPos = Vector3.Distance(vesselTransform.position, commandPosition);

			//if(distanceToPos > 100)
			//{

			float dotToPos = Vector3.Dot(vesselTransform.up, commandPosition - vesselTransform.position);
			Vector3 flyPos;
			useRollHint = false;

			float ctrlModeThresh = 1000;

			if(distanceToPos < ctrlModeThresh)
			{
				flyPos = commandPosition + (ctrlModeThresh * commandHeading);

				Vector3 vectorToFlyPos = flyPos - vessel.ReferenceTransform.position;
				Vector3 projectedPosOffset = Vector3.ProjectOnPlane(commandPosition - vessel.ReferenceTransform.position, commandHeading);
				float posOffsetMag = projectedPosOffset.magnitude;
				float adjustAngle = (Mathf.Clamp(posOffsetMag * 0.27f, 0, 25));
				Vector3 projVel = Vector3.Project(vessel.srf_velocity - commandLeader.vessel.srf_velocity, projectedPosOffset);
				adjustAngle -= Mathf.Clamp(Mathf.Sign(Vector3.Dot(projVel, projectedPosOffset)) * projVel.magnitude * 0.12f, -10, 10);

				adjustAngle *= Mathf.Deg2Rad;

				vectorToFlyPos = Vector3.RotateTowards(vectorToFlyPos, projectedPosOffset, adjustAngle, 0);

				flyPos = vessel.ReferenceTransform.position + vectorToFlyPos;

				if(distanceToPos < 400)
				{
					steerMode = SteerModes.Aiming;
				}
				else
				{
					steerMode = SteerModes.NormalFlight;
				}
				/*
				if(dotToPos < 0)
				{
					flyPos = commandPosition + (315 * commandHeading);
					s.mainThrottle = 0;
					vessel.ActionGroups.SetGroup(KSPActionGroup.Brakes, true);

					steerMode = SteerModes.NormalFlight;
				}
				*/
				if(distanceToPos < 15)
				{
					useRollHint = true;
				}
			}
			else
			{
				steerMode = SteerModes.NormalFlight;
				flyPos = commandPosition;
			}

			double finalMaxSpeed = commandSpeed;
			if(dotToPos > 0)
			{
				finalMaxSpeed += (distanceToPos / 8);
			}
			else
			{
				finalMaxSpeed -= (distanceToPos / 2);
			}


			AdjustThrottle((float)finalMaxSpeed, true);


			FlyToPosition(s, flyPos);
		}

		Vector3d GetFormationPosition()
		{
			Quaternion origVRot = velocityTransform.rotation;
			Vector3 origVLPos = velocityTransform.localPosition;

			velocityTransform.position = commandLeader.vessel.ReferenceTransform.position;
			if(commandLeader.vessel.srf_velocity != Vector3d.zero)
			{
				velocityTransform.rotation = Quaternion.LookRotation(commandLeader.vessel.srf_velocity, upDirection);
				velocityTransform.rotation = Quaternion.AngleAxis(90, velocityTransform.right) * velocityTransform.rotation;
			}
			else
			{
				velocityTransform.rotation = commandLeader.vessel.ReferenceTransform.rotation;
			}

			/*
			Vector3 lateralVelVector = Vector3.Project(vessel.srf_velocity, velocityTransform.right)/2;
			Vector3.ClampMagnitude(lateralVelVector, 25);

			Vector3 verticalVelVector = Vector3.Project(vessel.srf_velocity - commandLeader.vessel.srf_velocity, velocityTransform.forward) * 1;//0.75f; //MOVE THIS TO UpdateFollowCommand TO REGULATE VERTICAL POSITION AND SPEED
			Vector3.ClampMagnitude(verticalVelVector, 25);
			*/

			Vector3d pos = velocityTransform.TransformPoint(GetLocalFormationPosition(commandFollowIndex));// - lateralVelVector - verticalVelVector;

			velocityTransform.localPosition = origVLPos;
			velocityTransform.rotation = origVRot;

			return pos;
		}

		Vector3d GetLocalFormationPosition(int index)
		{
			float indexF = (float)index;
			indexF++;

			double rightSign = indexF % 2 == 0 ? -1 : 1;
			double positionFactor = Math.Ceiling(indexF/ 2);
			double spread = commandLeader.spread;
			double lag = commandLeader.lag;

			double right = rightSign * positionFactor * spread;
			double back = positionFactor * lag * -1;

			return new Vector3d(right, back, 0);
		}


		public void ReleaseCommand()
		{
			Debug.Log(vessel.vesselName + " was released from command.");
			command = PilotCommands.Free;

			defaultOrbitCoords = VectorUtils.WorldPositionToGeoCoords(vesselTransform.position, vessel.mainBody);
		}

		public void CommandFollow(ModuleWingCommander leader, int followerIndex)
		{
			Debug.Log(vessel.vesselName + " was commanded to follow.");
			command = PilotCommands.Follow;
			commandLeader = leader;
			commandFollowIndex = followerIndex;
		}

		void OnGUI()
		{
			if(pilotEnabled && vessel.isActiveVessel)	
			{
				if(BDArmorySettings.DRAW_DEBUG_LABELS)
				{
					GUI.Label(new Rect(200, Screen.height - 200, 400, 400), debugString);	
				}

				if(BDArmorySettings.DRAW_DEBUG_LINES)
				{
					if(command == PilotCommands.Follow)
					{
						BDGUIUtils.DrawLineBetweenWorldPositions(vesselTransform.position, commandPosition, 2, Color.red);
					}


				}


			}
		}

	}
}

