//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18449
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
namespace BahaTurret
{
	public class ModuleWeapon : PartModule, IBDWeapon
	{
		public static ObjectPool bulletPool;
		public static ObjectPool shellPool;

		public enum WeaponTypes{Ballistic, Cannon, Laser}
		public enum WeaponStates{Enabled, Disabled, PoweringUp, PoweringDown}
		public WeaponStates weaponState = WeaponStates.Disabled;

		//name
		[KSPField]
		public string shortName = string.Empty;

		//transforms
		[KSPField]
		public string fireTransformName = "fireTransform";
		public Transform[] fireTransforms;

		[KSPField]
		public string shellEjectTransformName = "shellEject";
		public Transform[] shellEjectTransforms;


		//animations
		private float fireAnimSpeed = 1; //is set when setting up animation so it plays a full animation for each shot (animation speed depends on rate of fire)
		[KSPField]
		public bool hasDeployAnim = false;
		[KSPField]
		public string deployAnimName = "deployAnim";
		AnimationState deployState;
		[KSPField]
		public bool hasFireAnimation = false;
		[KSPField]
		public string fireAnimName = "fireAnim";
		private AnimationState fireState;
		[KSPField]
		public bool spinDownAnimation = false;
		private bool spinningDown = false;


		//weapon specifications
		[KSPField]
		public float maxTargetingRange = 2000; //max range for raycasting and sighting
		[KSPField]
		public float roundsPerMinute = 850; //rate of fire
		[KSPField]
		public float maxDeviation = 1; //max inaccuracy deviation in degrees
		[KSPField]
		public float maxEffectiveDistance = 2500; //used by AI to select appropriate weapon
		[KSPField]
		public float bulletMass = 5.40133e-5f; //mass in tons - used for damage and recoil
		[KSPField]
		public float bulletVelocity = 860; //velocity in meters/second
		[KSPField]
		public string ammoName = "50CalAmmo"; //resource usage TODO: multi resource requirement
		[KSPField]
		public float requestResourceAmount = 1; //amount of resource/ammo to deplete per shot
		[KSPField]
		public float shellScale = 0.66f; //scale of shell to eject
		[KSPField]
		public bool hasRecoil = true;
		[KSPField(isPersistant = true, guiActive = false, guiActiveEditor = true, guiName = "Fire Limits"), 
		 UI_Toggle(disabledText = "None", enabledText = "In range")]
		public bool onlyFireInRange = true; //prevent firing when gun's turret is trying to exceed gimbal limits
		[KSPField]
		public bool bulletDrop = true; //projectiles are affected by gravity
		[KSPField]
		public string weaponType = "ballistic";  //ballistic(normal bullets), cannon(explosive bullets), or laser
		public WeaponTypes eWeaponType;
		[KSPField]
		public float laserDamage = 10000; //base damage/second of lasers

		//cannon shell specfications
		[KSPField]
		public float cannonShellRadius = 30; //max radius of explosion forces/damage
		[KSPField]
		public float cannonShellPower = 8; //explosion's impulse force

		//projectile graphics
		[KSPField]
		public string projectileColor = "255, 130, 0, 255"; //final color of projectile
		Color projectileColorC;
		[KSPField]
		public bool fadeColor = false;
		[KSPField]
		public string startColor = "255, 160, 0, 200"; //if fade color is true, projectile starts at this color
		Color startColorC;
		[KSPField]
		public float tracerStartWidth = 0.25f;
		[KSPField]
		public float tracerEndWidth = 0.2f;
		[KSPField]
		public float tracerLength = 0; //if set to zero, tracer will be the length of the distance covered by the projectile in one physics timestep
		[KSPField]
		public string bulletTexturePath = "BDArmory/Textures/bullet";

		[KSPField]
		public bool oneShotWorldParticles = false;

		
		//heat
		[KSPField]
		public float maxHeat = 3600;
		[KSPField]
		public float heatPerShot = 75;
		[KSPField]
		public float heatLoss = 250;
		public float heat = 0;
		public bool isOverheated = false;

		//canon explosion effects
		[KSPField]
		public string explModelPath = "BDArmory/Models/explosion/explosion";
		
		[KSPField]
		public string explSoundPath = "BDArmory/Sounds/explode1";
		//


		//Used for scaling laser damage down based on distance.
		[KSPField]
		public float tanAngle = 0.0001f;
		//Angle of divergeance/2. Theoretical minimum value calculated using Î¸ = (1.22 L/RL)/2, 
		//where L is laser's wavelength and RL is the radius of the mirror (=gun).


		//audioclip paths
		[KSPField]
		public string fireSoundPath = "BDArmory/Parts/50CalTurret/sounds/shot";
		[KSPField]
		public string overheatSoundPath = "BDArmory/Parts/50CalTurret/sounds/turretOverheat";
		[KSPField]
		public string chargeSoundPath = "BDArmory/Parts/laserTest/sounds/charge";

		//audio
		[KSPField]
		public bool oneShotSound = true; //play audioclip on every shot, instead of playing looping audio while firing
		[KSPField]
		public float soundRepeatTime = 1; //looped audio will loop back to this time (used for not playing the opening bit, eg the ramp up in pitch of gatling guns)
		[KSPField]
		public string reloadAudioPath = string.Empty;
		AudioClip reloadAudioClip;
		[KSPField]
		public string reloadCompletePath = string.Empty;
		private bool wasFiring = false; //used for knowing when to stop looped audio clip (when you're not shooting, but you were)
		AudioClip reloadCompleteAudioClip;
		AudioClip fireSound;
		AudioClip overheatSound;
		AudioClip chargeSound;
		AudioSource audioSource;
		AudioSource audioSource2;

		//AI
		public bool aiControlled = false;
		public bool autoFire = false;
		public float autoFireLength = 0;
		public float autoFireTimer = 0;
		//used by AI to lead moving targets
		private float targetDistance = 0;
		private Vector3 targetPosition;
		private Vector3 targetVelocity;
		private Vector3 targetAcceleration;
		Vector3 finalAimTarget;
		public Vessel legacyTargetVessel;
		bool targetAcquired = false;
		
		//used to reduce volume of audio if multiple guns are being fired (needs to be improved/changed)
		//private int numberOfGuns = 0;

		//UI gauges(next to staging icon)
		private VInfoBox heatGauge = null;
		private VInfoBox reloadBar = null;
		[KSPField]
		public bool showReloadMeter = false; //used for cannons or guns with extremely low rate of fire

		//AI will fire gun if target is within this angle(degrees) of barrel
		public float maxAutoFireAngle = 2;
		
		//aimer textures
		Vector3 pointingAtPosition;
		Vector3 bulletPrediction;
		Vector3 fixedLeadOffset = Vector3.zero;
		float targetLeadDistance = 0;

		//Air Detonating Rounds
		[KSPField]
		public bool airDetonation = false;
		[KSPField(isPersistant = true, guiActive = true, guiActiveEditor = true, guiName = "Default Detonation Range"),
		 UI_FloatRange(minValue = 500, maxValue = 3500f, stepIncrement = 1f, scene = UI_Scene.All)]
		public float defaultDetonationRange = 3500;
		float detonationRange = 2000;

		//gapless particles
		List<BDAGaplessParticleEmitter> gaplessEmitters = new List<BDAGaplessParticleEmitter>();


		//module references
		public ModuleTurret turret;
		MissileFire mf = null;
		public MissileFire weaponManager
		{
			get
			{
				if (!mf)
				{
					foreach (var wm in vessel.FindPartModulesImplementing<MissileFire>())
					{
						mf = wm;
						break;
					}
				}
				return mf;
			}
		}

		LineRenderer[] laserRenderers;

		//
		float timeFired = 0;
		bool pointingAtSelf = false; //true if weapon is pointing at own vessel
		bool userFiring = false;
		Vector3 laserPoint;
		public bool slaved = false;

		public Transform turretBaseTransform
		{
			get
			{
				if(turret)
				{
					return turret.yawTransform.parent;
				}
				else
				{
					return fireTransforms[0];
				}
			}
		}

		public float maxPitch
		{
			get
			{
				return turret ? turret.maxPitch : 0;
			}
		}

		public float minPitch
		{
			get
			{
				return turret ? turret.minPitch : 0;
			}
		}

		public float yawRange

		{
			get
			{
				return turret ? turret.yawRange : 0;
			}
		}

		//weapon interface
		public WeaponClasses GetWeaponClass()
		{
			return WeaponClasses.Gun;
		}

		public string GetShortName()
		{
			return shortName;
		}

		public Part GetPart()
		{
			return part;
		}


		//PartWindow buttons
		[KSPEvent(guiActive = true, guiActiveEditor = false, guiName = "Toggle")]
		public void Toggle()
		{
			if(weaponState == WeaponStates.Disabled || weaponState == WeaponStates.PoweringDown)
			{
				EnableWeapon();
			}
			else
			{
				DisableWeapon();
			}
		}


		public override void OnStart (StartState state)
		{
			base.OnStart (state);

			ParseWeaponType();

			if(shortName == string.Empty)
			{
				shortName = part.partInfo.title;
			}

			if(!airDetonation)
			{
				Fields["defaultDetonationRange"].guiActive = false;
				Fields["defaultDetonationRange"].guiActiveEditor = false;
			}

			if(HighLogic.LoadedSceneIsFlight)
			{
				if(eWeaponType!=WeaponTypes.Laser)
				{
					if(bulletPool == null)
					{
						SetupBulletPool();
					}
					if(shellPool == null)
					{
						SetupShellPool();
					}
				}

				//setup transforms
				fireTransforms = part.FindModelTransforms(fireTransformName);
				shellEjectTransforms = part.FindModelTransforms(shellEjectTransformName);

				//setup emitters
				foreach(var pe in part.FindModelComponents<KSPParticleEmitter>())
				{
					pe.maxSize *= part.rescaleFactor;
					pe.minSize *= part.rescaleFactor;
					pe.shape3D *= part.rescaleFactor;
					pe.shape2D *= part.rescaleFactor;
					pe.shape1D *= part.rescaleFactor;

					if(pe.useWorldSpace && !oneShotWorldParticles)	
					{
						BDAGaplessParticleEmitter gpe = pe.gameObject.AddComponent<BDAGaplessParticleEmitter>();	
						gpe.part = part;
						gaplessEmitters.Add(gpe);
					}
				}

				
				//setup projectile colors
				projectileColorC = Misc.ParseColor255(projectileColor);
				startColorC = Misc.ParseColor255(startColor);
				
				//init and zero points
				targetPosition = Vector3.zero;
				pointingAtPosition = Vector3.zero;
				bulletPrediction = Vector3.zero;

				//setup audio
				SetupAudio();

				//laser setup
				if(eWeaponType == WeaponTypes.Laser)
				{
					SetupLaserSpecifics();
				}


			}

			//turret setup
			turret = part.FindModuleImplementing<ModuleTurret>();
			if(!turret)
			{
				Fields["onlyFireInRange"].guiActive = false;
				Fields["onlyFireInRange"].guiActiveEditor = false;
			}


			//setup animations
			if(hasDeployAnim)
			{
				deployState = Misc.SetUpSingleAnimation(deployAnimName, this.part);
				deployState.normalizedTime = 0;
				deployState.speed = 0;
				deployState.enabled = true;
			}
			if(hasFireAnimation)
			{
				fireState = Misc.SetUpSingleAnimation (fireAnimName, this.part);
				fireState.enabled = false;	
			}

			BDArmorySettings.OnVolumeChange += UpdateVolume;
		}

		void UpdateVolume()
		{
			if(audioSource)
			{
				audioSource.volume = BDArmorySettings.BDARMORY_WEAPONS_VOLUME;
			}
			if(audioSource2)
			{
				audioSource2.volume = BDArmorySettings.BDARMORY_WEAPONS_VOLUME;
			}
		}

		void OnDestroy()
		{
			BDArmorySettings.OnVolumeChange -= UpdateVolume;
		}

		void Update()
		{
			if(HighLogic.LoadedSceneIsFlight && FlightGlobals.ready && !vessel.packed)
			{

				if(InternalCamera.Instance && InternalCamera.Instance.isActive)
				{
					lowpassFilter.enabled = true;
				}
				else
				{
					lowpassFilter.enabled = false;
				}
	
				if(weaponState == WeaponStates.Enabled && (TimeWarp.WarpMode!=TimeWarp.Modes.HIGH || TimeWarp.CurrentRate == 1))
				{
					UpdateTargetVessel();
					Aim ();

					userFiring = (Input.GetKey(BDArmorySettings.FIRE_KEY) && (vessel.isActiveVessel || BDArmorySettings.REMOTE_SHOOTING) && !MapView.MapIsEnabled && !aiControlled);
					if((userFiring || autoFire) && (!turret || turret.TargetInRange(finalAimTarget, 10, float.MaxValue)))
					{
						if(eWeaponType == WeaponTypes.Ballistic || eWeaponType == WeaponTypes.Cannon)
						{
							Fire ();
						}
					}
					else
					{
						if(spinDownAnimation) spinningDown = true;
						if(eWeaponType == WeaponTypes.Laser) audioSource.Stop ();
						if(!oneShotSound && wasFiring)
						{
							audioSource.Stop ();
							wasFiring = false;
							audioSource2.PlayOneShot(overheatSound);	
						}
					}


				}
				else
				{
					audioSource.Stop ();
					autoFire = false;
				}

				if(spinningDown && spinDownAnimation && hasFireAnimation)
				{
					if(fireState.normalizedTime>1) fireState.normalizedTime = 0;
					fireState.speed = fireAnimSpeed;
					fireAnimSpeed = Mathf.Lerp(fireAnimSpeed, 0, 0.04f);
				}
				
				
			}
		}


		void FixedUpdate()
		{
			if(HighLogic.LoadedSceneIsFlight && !vessel.packed)
			{
				if(showReloadMeter)
				{
					UpdateReloadMeter();
				}
				else
				{
					UpdateHeatMeter();
				}
				UpdateHeat();


				if(weaponState == WeaponStates.Enabled && (TimeWarp.WarpMode!=TimeWarp.Modes.HIGH || TimeWarp.CurrentRate == 1))
				{
					CheckWeaponSafety();
					RunTrajectorySimulation();
				
					if(eWeaponType == WeaponTypes.Laser)
					{
						if((userFiring || autoFire) && (!turret || turret.TargetInRange(targetPosition, 10, float.MaxValue)))
						{
							if(FireLaser())
						   	{
								for(int i = 0; i < laserRenderers.Length; i++)
								{
									laserRenderers[i].enabled = true;
								}
							}
							else
							{
								for(int i = 0; i < laserRenderers.Length; i++)
								{
									laserRenderers[i].enabled = false;
								}
								audioSource.Stop ();	
							}
						}
						else
						{
							for(int i = 0; i < laserRenderers.Length; i++)
							{
								laserRenderers[i].enabled = false;
							}
							audioSource.Stop ();	
						}
					}
				}
				else if(eWeaponType == WeaponTypes.Laser)
				{
					for(int i = 0; i < laserRenderers.Length; i++)
					{
						laserRenderers[i].enabled = false;
					}
					audioSource.Stop ();	
				}


				//autofiring with AI
				if(targetAcquired && aiControlled)
				{
					Transform fireTransform = fireTransforms[0];
					Vector3 targetDirection = (finalAimTarget)-fireTransform.position;
					Vector3 aimDirection = fireTransform.forward;
					float targetAngle = Vector3.Angle(aimDirection, targetDirection);

					if(targetAngle < maxAutoFireAngle)
					{
						autoFire = true;
					}
					else
					{
						autoFire = false;
					}
				}
				else
				{	
					autoFire = false;
				}

				//disable autofire after burst length
				if(autoFire && Time.time-autoFireTimer > autoFireLength)
				{
					autoFire = false;
					legacyTargetVessel = null;
				}

			}
		}
			


		//Aiming used if part has a turret module
		void Aim()
		{
			//AI control
			if(aiControlled)
			{
				if(BDArmorySettings.ALLOW_LEGACY_TARGETING && legacyTargetVessel)
				{
					targetPosition += legacyTargetVessel.rb_velocity * Time.fixedDeltaTime;
				}
				else if(!targetAcquired)
				{
					autoFire = false;
					return;
				}
			}



			if(!slaved && !aiControlled && (yawRange > 0 || maxPitch-minPitch > 0))
			{
				//MouseControl
				Vector3 mouseAim = new Vector3(Input.mousePosition.x/Screen.width, Input.mousePosition.y/Screen.height, 0);
				Ray ray = FlightCamera.fetch.mainCamera.ViewportPointToRay(mouseAim);
				RaycastHit hit;
				if(Physics.Raycast(ray, out hit, maxTargetingRange, 557057))
				{
					targetPosition = hit.point;

					//aim through self vessel if occluding mouseray
					Part p = hit.collider.gameObject.GetComponentInParent<Part>();
					if(p && p.vessel && p.vessel == vessel)
					{
						targetPosition = ray.direction * maxTargetingRange + FlightCamera.fetch.mainCamera.transform.position; 
					}
				}
				else
				{
					targetPosition = (ray.direction * (maxTargetingRange+(FlightCamera.fetch.Distance*0.75f))) + FlightCamera.fetch.mainCamera.transform.position;	
					if(legacyTargetVessel!=null && legacyTargetVessel.loaded)
					{
						targetPosition = ray.direction * Vector3.Distance(legacyTargetVessel.transform.position, FlightCamera.fetch.mainCamera.transform.position) + FlightCamera.fetch.mainCamera.transform.position;	
					}
				}
			}


			//aim assist
			Vector3 finalTarget = targetPosition;
			Vector3 originalTarget = targetPosition;
			targetDistance = Vector3.Distance(finalTarget, transform.position);

			if((BDArmorySettings.AIM_ASSIST || aiControlled) && eWeaponType!=WeaponTypes.Laser)
			{
				float gAccel = (float) FlightGlobals.getGeeForceAtPosition(finalTarget).magnitude;
				float time = targetDistance/(bulletVelocity);

				if(targetAcquired)
				{
					Vector3 acceleration = targetAcceleration;
					float time2 = VectorUtils.CalculateLeadTime(finalTarget-transform.position, targetVelocity-vessel.srf_velocity, bulletVelocity);
					if(time2 > 0) time = time2;
					finalTarget += (targetVelocity-vessel.srf_velocity) * time; //target vessel relative velocity compensation
					finalTarget += (0.5f * acceleration * time * time); //target acceleration
				}
				else if(vessel.altitude < 6000)
				{
					float time2 = VectorUtils.CalculateLeadTime(finalTarget-transform.position, Vector3.zero-part.rb.velocity, bulletVelocity);
					if(time2 > 0) time = time2;
					finalTarget += (-part.rb.velocity*(time+Time.fixedDeltaTime));  //this vessel velocity compensation against stationary
				}
				if(bulletDrop && vessel.srf_velocity.sqrMagnitude < Mathf.Pow(750,2)) finalTarget += (0.5f*gAccel*time*time * FlightGlobals.getUpAxis());  //gravity compensation
				
				targetLeadDistance = Vector3.Distance(finalTarget, transform.position);
				//fixedLeadOffset = originalTarget-pointingAtPosition;
				
				//if(yawRange < 1)
				//{
					fixedLeadOffset = originalTarget-finalTarget; //for aiming fixed guns to moving target	
				//}
				
				//airdetonation
				if(targetAcquired)
				{
					detonationRange = Mathf.Clamp(Vector3.Distance(transform.position, finalTarget), 500, 3500) - 50f;
				}
				else
				{
					detonationRange = defaultDetonationRange;
				}
				
			}
			
			detonationRange *= UnityEngine.Random.Range(0.95f, 1.05f);


			//target -= part.rb.velocity*Time.fixedDeltaTime;

			finalAimTarget = finalTarget;

			//final turret aiming
			if(slaved && !targetAcquired) return;
			if(turret)
			{
				bool origSmooth = turret.smoothRotation;
				if(aiControlled || slaved)
				{
					turret.smoothRotation = false;
				}
				turret.AimToTarget(finalTarget);
				turret.smoothRotation = origSmooth;
			}
		}

		private void Fire()
		{
			if(BDArmorySettings.GameIsPaused)
			{
				if(audioSource.isPlaying)
				{
					audioSource.Stop();	
				}
				return;
			}

			float timeGap = (60/roundsPerMinute) * TimeWarp.CurrentRate;
			
			if(Time.time-timeFired > timeGap && !isOverheated && !pointingAtSelf)
			{
				bool effectsShot = false;
				//Transform[] fireTransforms = part.FindModelTransforms("fireTransform");
				for(int i = 0; i < fireTransforms.Length; i++)
				{
					if(!Misc.CheckMouseIsOnGui() && WMgrAuthorized() && (BDArmorySettings.INFINITE_AMMO || part.RequestResource(ammoName, requestResourceAmount)>0))
					{
						Transform fireTransform = fireTransforms[i];
						spinningDown = false;

						//recoil
						if(hasRecoil)
						{
							gameObject.rigidbody.AddForceAtPosition((-fireTransform.forward) * (bulletVelocity*bulletMass), fireTransform.position, ForceMode.Impulse);
						}
						
						if(!effectsShot)
						{
							//sound
							if(oneShotSound)
							{
								audioSource.dopplerLevel = 0;
								audioSource.bypassListenerEffects = true;
								audioSource.PlayOneShot(fireSound);
							}
							else
							{
								wasFiring = true;
								if(!audioSource.isPlaying)
								{
									audioSource.clip = fireSound;
									audioSource.dopplerLevel = 0;
									audioSource.bypassListenerEffects = true;
									audioSource.loop = false;
									audioSource.time = 0;
									audioSource.Play();	
								}
								else
								{
									if (audioSource.time >= fireSound.length)
									{
										audioSource.time = soundRepeatTime;	
									}
								}
							}

							//animation
							if(hasFireAnimation)
							{
								float unclampedSpeed = (roundsPerMinute*fireState.length)/60;
								fireAnimSpeed = Mathf.Clamp (unclampedSpeed, 1, 20);
								fireState.enabled = true;
								if(unclampedSpeed == fireAnimSpeed)
								{
									fireState.normalizedTime = 0;
								}
								fireState.speed = fireAnimSpeed;
								fireState.normalizedTime = Mathf.Repeat(fireState.normalizedTime, 1);
							}
							
							//muzzle flash

							foreach(Transform mtf in part.FindModelTransforms("muzzleTransform"))
							{
								KSPParticleEmitter pEmitter = mtf.gameObject.GetComponent<KSPParticleEmitter>();
								if(!pEmitter.useWorldSpace || oneShotWorldParticles)
								{
									pEmitter.Emit();
								}
							}

							foreach(var gpe in gaplessEmitters)
							{
								gpe.EmitParticles();	
							}
							
							//shell ejection
							if(BDArmorySettings.EJECT_SHELLS)
							{
								for(int e = 0; e < shellEjectTransforms.Length; e++)
								{
									Transform sTf = shellEjectTransforms[e];
									//GameObject ejectedShell = (GameObject) Instantiate(GameDatabase.Instance.GetModel("BDArmory/Models/shell/model"), sTf.position + (part.rb.velocity*Time.fixedDeltaTime), sTf.rotation);
									GameObject ejectedShell = shellPool.GetPooledObject();
									ejectedShell.transform.position = sTf.position+(part.rb.velocity*TimeWarp.fixedDeltaTime);
									ejectedShell.transform.rotation = sTf.rotation;
									ejectedShell.transform.localScale = Vector3.one * shellScale;
									ShellCasing shellComponent = ejectedShell.GetComponent<ShellCasing>();
									shellComponent.initialV = part.rb.velocity;
									ejectedShell.SetActive(true);
								}
							}
							effectsShot = true;
						}
						
						
						//firing bullet
						GameObject firedBullet = bulletPool.GetPooledObject();
						PooledBullet pBullet = firedBullet.GetComponent<PooledBullet>();
						firedBullet.transform.position = fireTransform.position;
						pBullet.mass = bulletMass;
						
						
						//Vector3 firedVelocity = fireTransform.rotation * new Vector3(randomZ,randomY,bulletVelocity).normalized * bulletVelocity;
						Vector3 firedVelocity = VectorUtils.WeightedDirectionDeviation(fireTransform.forward, maxDeviation) * bulletVelocity;
							
						/*
						if(targetVessel!=null && targetVessel.loaded && (autoLockCapable || guardMode))
						{
							Vector3 targetDirection = targetPosition-fireTransform.position;
							
							if(Vector3.Angle(aimDirection, targetDirection) < 3f)
							{
								firedVelocity = Quaternion.LookRotation(targetDirection) * new Vector3(randomZ,randomY,bulletVelocity).normalized * bulletVelocity;
							}
						}
						*/

						//firedBullet.transform.position -= firedVelocity * Time.fixedDeltaTime;
						firedBullet.transform.position += part.rb.velocity * Time.fixedDeltaTime;
						pBullet.currentVelocity = part.rb.velocity + firedVelocity;

						pBullet.initialSpeed = bulletVelocity;
						pBullet.sourceVessel = this.vessel;
						pBullet.bulletTexturePath = bulletTexturePath;
						pBullet.projectileColor = projectileColorC;
						pBullet.startColor = startColorC;
						pBullet.fadeColor = fadeColor;
						pBullet.tracerStartWidth = tracerStartWidth;
						pBullet.tracerEndWidth = tracerEndWidth;
						pBullet.tracerLength = tracerLength;
						pBullet.bulletDrop = bulletDrop;
						
						if(weaponType == "cannon")
						{
							pBullet.bulletType = PooledBullet.PooledBulletTypes.Explosive;
							pBullet.explModelPath = explModelPath;
							pBullet.explSoundPath = explSoundPath;
							pBullet.blastPower = cannonShellPower;
							pBullet.radius = cannonShellRadius;
							pBullet.airDetonation = airDetonation;
							pBullet.detonationRange = detonationRange;
						}
						else
						{
							pBullet.bulletType = PooledBullet.PooledBulletTypes.Standard;
							pBullet.airDetonation = false;
						}

						pBullet.gameObject.SetActive(true);

						
						//heat
						heat += heatPerShot;
					}
					else
					{
						spinningDown = true;
						if(!oneShotSound && wasFiring)
						{
							audioSource.Stop ();
							wasFiring = false;
							audioSource2.PlayOneShot(overheatSound);	
						}
					}
				}

				timeFired = Time.time;
			}
			else
			{
				spinningDown = true;	
			}
		}


		private bool FireLaser()
		{
			float maxDistance = BDArmorySettings.PHYSICS_RANGE;
			if(BDArmorySettings.PHYSICS_RANGE == 0) maxDistance = 2500;
			
			float chargeAmount = requestResourceAmount * TimeWarp.fixedDeltaTime;
			if(!Misc.CheckMouseIsOnGui() && WMgrAuthorized() && !isOverheated && (part.RequestResource(ammoName, chargeAmount)>=chargeAmount || BDArmorySettings.INFINITE_AMMO))
			{
				if(!audioSource.isPlaying)
				{
					audioSource.PlayOneShot (chargeSound);
					audioSource.Play();
					audioSource.loop = true;
					
				}
				for(int i = 0; i < fireTransforms.Length; i++)
				{
					Transform tf = fireTransforms[i];

					LineRenderer lr = laserRenderers[i];
					//lr.SetPosition(0, tf.position + (part.rb.velocity*Time.fixedDeltaTime));
					
					Vector3 rayDirection = tf.forward;
					
					Vector3 targetDirection = Vector3.zero;  //autoTrack enhancer
					Vector3 targetDirectionLR = tf.forward;
					Vector3 physStepFix = Vector3.zero;


					if(legacyTargetVessel!=null && legacyTargetVessel.loaded)
					{
						targetDirection = (legacyTargetVessel.CoM+(legacyTargetVessel.rb_velocity*Time.fixedDeltaTime)) - tf.position;
						physStepFix = legacyTargetVessel.rb_velocity*Time.fixedDeltaTime;


						if(Vector3.Angle(rayDirection, targetDirection) < 1)
						{
							rayDirection = targetDirection;
							targetDirectionLR = (legacyTargetVessel.CoM+(2*legacyTargetVessel.rb_velocity*Time.fixedDeltaTime)) - tf.position;
						}
					}
					else if(slaved)
					{
						foreach(var mtc in vessel.FindPartModulesImplementing<ModuleTargetingCamera>())
						{
							targetDirection = mtc.targetPointPosition-tf.position;

							if(Vector3.Angle(rayDirection, targetDirection)<1)
							{
								rayDirection = targetDirection;
								targetDirectionLR = targetDirection;
							}
							break;
						}
					}
					


					Ray ray = new Ray(tf.position, rayDirection);
					RaycastHit hit;
					if(Physics.Raycast(ray, out hit, maxDistance, 557057))
					{
						laserPoint = hit.point + (physStepFix);
						lr.SetPosition(1, lr.transform.InverseTransformPoint(laserPoint));

						if(Time.time-timeFired > 6/120 && BDArmorySettings.BULLET_HITS)
						{
							BulletHitFX.CreateBulletHit(hit.point, hit.normal, false);	
						}

						Part p = hit.collider.gameObject.GetComponentInParent<Part>();
						if(p && p.vessel && p.vessel!=this.vessel)
						{
							float distance = hit.distance;
							p.temperature += laserDamage/(float)(Math.PI*Math.Pow(tanAngle*distance,2))*TimeWarp.fixedDeltaTime; //distance modifier: 1/(PI*Pow(Dist*tan(angle),
							
							if(BDArmorySettings.INSTAKILL) p.temperature += p.maxTemp;
						}
					}
					else
					{
						laserPoint = lr.transform.InverseTransformPoint((targetDirectionLR*maxDistance)+tf.position);
						lr.SetPosition(1, laserPoint);
					}
				}
				heat += heatPerShot * TimeWarp.CurrentRate;
				return true;
			}
			else
			{
				return false;
			}
		}



		bool WMgrAuthorized()
		{
			MissileFire manager = BDArmorySettings.Instance.ActiveWeaponManager;
			if(manager != null)
			{
				if(manager.hasSingleFired) return false;
				else return true;
			}
			else
			{
				return true;	
			}
		}
	
		void CheckWeaponSafety()
		{
			pointingAtSelf = false;
			for(int i = 0; i < fireTransforms.Length; i++)
			{
				Ray ray = new Ray(fireTransforms[i].position, fireTransforms[i].forward);
				RaycastHit hit;
				if(Physics.Raycast(ray, out hit, maxTargetingRange, 557057))
				{
					Part p = hit.collider.gameObject.GetComponentInParent<Part>();
					if(p && p.vessel && p.vessel == vessel)
					{
						pointingAtSelf = true;
						break;
					}
				}
				else
				{
					pointingAtSelf = false;
				}
				
				
				if(targetAcquired)
				{
					pointingAtPosition = fireTransforms[i].transform.position + (ray.direction * targetLeadDistance);
				}
				else
				{
					pointingAtPosition = fireTransforms[i].position + (ray.direction * (maxTargetingRange));
				}
			}
		}

		void RunTrajectorySimulation()
		{
			//trajectory simulation
			if(BDArmorySettings.AIM_ASSIST && BDArmorySettings.DRAW_AIMERS)
			{
				Transform fireTransform = fireTransforms[0];

				if(eWeaponType == WeaponTypes.Laser)
				{
					Ray ray = new Ray(fireTransform.position, fireTransform.forward);
					RaycastHit rayHit;
					if(Physics.Raycast(ray, out rayHit,  maxTargetingRange, 557057))
					{
						bulletPrediction = rayHit.point;
					}
					else
					{
						bulletPrediction = ray.GetPoint(maxTargetingRange);
					}
					
					pointingAtPosition = ray.GetPoint(maxTargetingRange);
				}
				else //ballistic/cannon weapons
				{
					float simDeltaTime = 0.15f;
					
					
					Vector3 simVelocity = part.rb.velocity+(bulletVelocity*fireTransform.forward);
					Vector3 simCurrPos = fireTransform.position + (part.rb.velocity*Time.fixedDeltaTime);
					Vector3 simPrevPos = fireTransform.position + (part.rb.velocity*Time.fixedDeltaTime);
					Vector3 simStartPos = fireTransform.position + (part.rb.velocity*Time.fixedDeltaTime);
					bool simulating = true;
					
					List<Vector3> pointPositions = new List<Vector3>();
					pointPositions.Add(simCurrPos);
					
					while(simulating)
					{
						
						RaycastHit hit;
						if(bulletDrop) simVelocity += FlightGlobals.getGeeForceAtPosition(simCurrPos) * simDeltaTime;
						simCurrPos += simVelocity * simDeltaTime;
						pointPositions.Add(simCurrPos);
						if(Physics.Raycast(simPrevPos,simCurrPos-simPrevPos, out hit, Vector3.Distance(simPrevPos,simCurrPos), 557057))
						{
							Vessel hitVessel = null;
							try
							{
								hitVessel = Part.FromGO(hit.rigidbody.gameObject).vessel;	
							}
							catch(NullReferenceException){}
							
							if(hitVessel==null || (hitVessel!=null && hitVessel != vessel))
							{
								bulletPrediction = hit.point;
								simulating = false;
							}
							
						}
						
						
						simPrevPos = simCurrPos;
						
						if(legacyTargetVessel!=null && legacyTargetVessel.loaded && !legacyTargetVessel.Landed && Vector3.Distance(simStartPos,simCurrPos) > targetLeadDistance)
						{
							bulletPrediction = simStartPos + (simCurrPos-simStartPos).normalized*targetLeadDistance;
							simulating = false;
						}
						
						if((simStartPos-simCurrPos) .sqrMagnitude> Mathf.Pow(maxTargetingRange, 2))
						{
							
							bulletPrediction = simStartPos + ((simCurrPos-simStartPos).normalized*maxTargetingRange);
							simulating = false;
						}
					}
					
					
					if(BDArmorySettings.DRAW_DEBUG_LINES && BDArmorySettings.DRAW_AIMERS)
					{
						Vector3[] pointsArray = pointPositions.ToArray();
						if(gameObject.GetComponent<LineRenderer>()==null)
						{
							LineRenderer lr = gameObject.AddComponent<LineRenderer>();
							lr.SetWidth(.1f, .1f);
							lr.SetVertexCount(pointsArray.Length);
							for(int i = 0; i<pointsArray.Length; i++)
							{
								lr.SetPosition(i, pointsArray[i]);	
							}
						}
						else
						{
							LineRenderer lr = gameObject.GetComponent<LineRenderer>();
							lr.enabled = true;
							lr.SetVertexCount(pointsArray.Length);
							for(int i = 0; i<pointsArray.Length; i++)
							{
								lr.SetPosition(i, pointsArray[i]);	
							}	
						}
					}
					else
					{
						/*
						if(gameObject.GetComponent<LineRenderer>()!=null)
						{
							gameObject.GetComponent<LineRenderer>().enabled = false;	
						}
						*/
					}
					
				}

			}
		}

		public void EnableWeapon()
		{
			if(weaponState == WeaponStates.Enabled || weaponState == WeaponStates.PoweringUp)
			{
				return;
			}

			if(weaponState == WeaponStates.PoweringDown)
			{
				StopCoroutine("ShutdownRoutine");
			}

			StartCoroutine("StartupRoutine");
		}

		IEnumerator StartupRoutine()
		{
			weaponState = WeaponStates.PoweringUp;

			if(hasDeployAnim && deployState)
			{
				deployState.enabled = true;
				deployState.speed = 1;
				while(deployState.normalizedTime < 1)//wait for animation here
				{
					yield return null;
				}
				deployState.normalizedTime = 1;
				deployState.speed = 0;
				deployState.enabled = false;
			}

			weaponState = WeaponStates.Enabled;
		}
		
		public void DisableWeapon()
		{
			if(weaponState == WeaponStates.Disabled || weaponState == WeaponStates.PoweringDown)
			{
				return;
			}

			if(weaponState == WeaponStates.PoweringUp)
			{
				StopCoroutine("StartupRoutine");
			}

			StartCoroutine("ShutdownRoutine");
		}

		IEnumerator ShutdownRoutine()
		{
			weaponState = WeaponStates.PoweringDown;
			if(turret)
			{
				while(!turret.ReturnTurret()) //wait till turret has returned
				{
					yield return null;
				}
			}

			if(hasDeployAnim)
			{
				deployState.enabled = true;
				deployState.speed = -1;
				while(deployState.normalizedTime > 0)
				{
					yield return null;
				}
				deployState.normalizedTime = 0;
				deployState.speed = 0;
				deployState.enabled = false;
			}

			weaponState = WeaponStates.Disabled;
		}

		void UpdateHeat()
		{
			heat = Mathf.Clamp(heat - heatLoss * TimeWarp.fixedDeltaTime, 0, Mathf.Infinity);
			if(heat>maxHeat && !isOverheated)
			{
				isOverheated = true;
				autoFire = false;
				audioSource.Stop ();
				wasFiring = false;
				audioSource2.PlayOneShot(overheatSound);
			}
			if(heat < maxHeat/3 && isOverheated) //reset on cooldown
			{
				isOverheated = false;
				heat = 0;
			}
		}

		void UpdateHeatMeter()
		{
			//heat
			if(heat > maxHeat/3)
			{
				if(heatGauge == null)
				{
					heatGauge = InitHeatGauge();
				}
				heatGauge.SetValue(heat, maxHeat/3, maxHeat);
			}
			else if(heatGauge != null && heat < maxHeat/4)
			{
				part.stackIcon.ClearInfoBoxes();
				heatGauge = null;
			}
		}

		void UpdateReloadMeter()
		{
			if(Time.time-timeFired < (60/roundsPerMinute) && Time.time-timeFired > 0.1f)
			{
				if(reloadBar == null)
				{
					reloadBar = InitReloadBar();
					if(reloadAudioClip)
					{
						audioSource.PlayOneShot(reloadAudioClip);
					}
				}
				reloadBar.SetValue(Time.time-timeFired, 0, 60/roundsPerMinute);
			}
			else if(reloadBar != null)
			{
				part.stackIcon.ClearInfoBoxes();
				reloadBar = null;
				if(reloadCompleteAudioClip)
				{
					audioSource.PlayOneShot(reloadCompleteAudioClip);
				}
				
			}
		}

		AudioLowPassFilter lowpassFilter;
		void SetupAudio()
		{
			fireSound = GameDatabase.Instance.GetAudioClip(fireSoundPath);
			overheatSound = GameDatabase.Instance.GetAudioClip(overheatSoundPath);
			audioSource = gameObject.AddComponent<AudioSource>();
			audioSource.bypassListenerEffects = true;
			audioSource.minDistance = .3f;
			audioSource.maxDistance = 1000;
			audioSource.priority = 10;
			audioSource.dopplerLevel = 0;
			
			audioSource2 = gameObject.AddComponent<AudioSource>();
			audioSource2.bypassListenerEffects = true;
			audioSource2.minDistance = .3f;
			audioSource2.maxDistance = 1000;
			audioSource2.dopplerLevel = 0;
			audioSource2.priority = 10;
			
			if(reloadAudioPath != string.Empty)
			{
				reloadAudioClip = (AudioClip) GameDatabase.Instance.GetAudioClip(reloadAudioPath);
			}
			if(reloadCompletePath != string.Empty)
			{
				reloadCompleteAudioClip = (AudioClip) GameDatabase.Instance.GetAudioClip(reloadCompletePath);
			}

			lowpassFilter = gameObject.AddComponent<AudioLowPassFilter>();
			lowpassFilter.cutoffFrequency = 4000f;
			lowpassFilter.lowpassResonaceQ = 1f;

			UpdateVolume();
		}

		void SetupLaserSpecifics()
		{
			chargeSound = GameDatabase.Instance.GetAudioClip(chargeSoundPath);
			if(HighLogic.LoadedSceneIsFlight)
			{
				audioSource.clip = fireSound;
			}

			laserRenderers = new LineRenderer[fireTransforms.Length];

			for(int i = 0; i < fireTransforms.Length; i++)
			{
				Transform tf = fireTransforms[i];
				laserRenderers[i] = tf.gameObject.AddComponent<LineRenderer>();
				Color laserColor = Misc.ParseColor255(projectileColor);
				laserColor.a = laserColor.a/2;
				laserRenderers[i].material = new Material(Shader.Find ("KSP/Particles/Alpha Blended"));
				laserRenderers[i].material.SetColor("_TintColor", laserColor);
				laserRenderers[i].material.mainTexture = GameDatabase.Instance.GetTexture("BDArmory/Textures/laser", false);
				laserRenderers[i].castShadows = false;
				laserRenderers[i].receiveShadows = false;
				laserRenderers[i].SetWidth(tracerStartWidth, tracerEndWidth);
				laserRenderers[i].SetVertexCount(2);
				laserRenderers[i].SetPosition(0, Vector3.zero);
				laserRenderers[i].SetPosition(1, Vector3.zero);
				laserRenderers[i].useWorldSpace = false;
				laserRenderers[i].enabled = false;

			}
		}

		void ParseWeaponType()
		{
			weaponType = weaponType.ToLower();

			switch (weaponType)
			{
			case "ballistic":
				eWeaponType = WeaponTypes.Ballistic;
				break;

			case "cannon":
				eWeaponType = WeaponTypes.Cannon;
				break;

			case "laser":
				eWeaponType = WeaponTypes.Laser;
				break;
			}
		}

		private VInfoBox InitReloadBar()
		{
			VInfoBox v = part.stackIcon.DisplayInfo();
			
			v.SetMsgBgColor(XKCDColors.DarkGrey);
			v.SetMsgTextColor(XKCDColors.White);
			v.SetMessage("Reloading");
			v.SetProgressBarBgColor(XKCDColors.DarkGrey);
			v.SetProgressBarColor(XKCDColors.Silver);
			
			return v;
		}

		private VInfoBox InitHeatGauge()  //thanks DYJ
		{
			VInfoBox v = part.stackIcon.DisplayInfo();
			
			v.SetMsgBgColor(XKCDColors.DarkRed);
			v.SetMsgTextColor(XKCDColors.Orange);
			v.SetMessage("Overheat");
			v.SetProgressBarBgColor(XKCDColors.DarkRed);
			v.SetProgressBarColor(XKCDColors.Orange);
			
			return v;
		}

		void SetupBulletPool()
		{
			GameObject templateBullet = new GameObject("Bullet");
			templateBullet.SetActive(false);
			templateBullet.AddComponent<PooledBullet>();


			bulletPool = ObjectPool.CreateObjectPool(templateBullet, 100, true, true);
		}

		void SetupShellPool()
		{
			GameObject templateShell = (GameObject) Instantiate(GameDatabase.Instance.GetModel("BDArmory/Models/shell/model"));
			templateShell.SetActive(false);
			templateShell.AddComponent<ShellCasing>();

			shellPool = ObjectPool.CreateObjectPool(templateShell, 50, true, true);
		}

		public Vector3 GetLeadOffset()
		{
			return fixedLeadOffset;
		}

		void UpdateTargetVessel()
		{
			targetAcquired = false;
			slaved = false;

			//targetVessel = null;
			if(BDArmorySettings.ALLOW_LEGACY_TARGETING)
			{
				if(vessel.targetObject != null && vessel.targetObject.GetVessel() != null)
				{
					Vessel targetVessel = vessel.targetObject.GetVessel();
					targetPosition = targetVessel.CoM;
					targetVelocity = targetVessel.srf_velocity;
					targetAcceleration = targetVessel.acceleration;
					targetAcquired = true;
					return;
				}
			}

			//radar targeting
			if(weaponManager && weaponManager.radar)
			{
				if(weaponManager.radar.locked)
				{
					targetPosition = weaponManager.radar.lockedTarget.predictedPosition + (weaponManager.radar.lockedTarget.velocity * Time.fixedDeltaTime);
					targetVelocity = weaponManager.radar.lockedTarget.velocity;
					targetAcceleration = weaponManager.radar.lockedTarget.acceleration;
					targetAcquired = true;
				}
				if(weaponManager.radar.slaveTurrets && turret)
				{
					slaved = true;
				}	
				return;
			}

			//laser targeting
			if(ModuleTargetingCamera.activeCam && ModuleTargetingCamera.activeCam.vessel == vessel && ModuleTargetingCamera.activeCam.slaveTurrets)
			{
				if(turret)
				{
					slaved = true;
				}
				targetPosition = ModuleTargetingCamera.activeCam.targetPointPosition;
				targetVelocity = Vector3.zero;
				targetAcceleration = Vector3.zero;
				targetAcquired = true;
				return;
			}

		}



		void OnGUI()
		{
			if(weaponState == WeaponStates.Enabled && vessel && !vessel.packed && vessel.isActiveVessel && BDArmorySettings.DRAW_AIMERS && !aiControlled & !MapView.MapIsEnabled)
			{
				float size = 30;
				
				Vector3 reticlePosition;
				if(BDArmorySettings.AIM_ASSIST && vessel.srf_velocity.sqrMagnitude < Mathf.Pow(750,2))
				{
					if(targetAcquired && (slaved || yawRange < 1 || maxPitch-minPitch < 1))
					{
						reticlePosition = pointingAtPosition+fixedLeadOffset;

						if(!slaved)
						{
							BDGUIUtils.DrawLineBetweenWorldPositions(pointingAtPosition, reticlePosition, 2, new Color(0, 1, 0, 0.6f));
						}

						BDGUIUtils.DrawTextureOnWorldPos(pointingAtPosition, BDArmorySettings.Instance.greenDotTexture, new Vector2(6, 6), 0);
					}
					else
					{
						reticlePosition = bulletPrediction;
					}
				}
				else
				{
					reticlePosition = pointingAtPosition;
				}
				

				
				Texture2D texture;
				if(Vector3.Angle(pointingAtPosition-transform.position, finalAimTarget-transform.position) < 1f)
				{
					texture = BDArmorySettings.Instance.greenSpikedPointCircleTexture;
				}
				else
				{
					texture = BDArmorySettings.Instance.greenPointCircleTexture;
				}
				BDGUIUtils.DrawTextureOnWorldPos (reticlePosition, texture, new Vector2 (size, size), 0);
			}
		}



	}
}

